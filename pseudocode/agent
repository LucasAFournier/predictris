class ActiveSequence:
    current_node: UUID
    entry_node: UUID
    context: Context

class Agent:
    action_dict = ...
    perception_dict = ...

    def __init__(self):
        self.prediction_forest = dict[tuple, PredictionTree]()
        self.active_sequences = dict[PredictionTree, set[ActiveSequence]]()
        
    def init_episode(self):
        self.prev_obs = self.observe()
        
        # create tree if it doesn't exist for the observation
        self.prediction_forest.setdefault(
            self.prev_obs, PredictionTree(self.prev_obs)
        )

    def learn(self):
        # act randomly
        action = random.choice(list(self.action_dict))
        self.perform(action)

        # update current context
        self.current_context = Context(self.prev_obs, action)

        # perceive 
        obs = self.observe()

        # create tree if it doesn't exist for the observation
        tree = self.prediction_forest.setdefault(
            obs, PredictionTree(obs)
        )

        # context propagation
        new_active = dict()
        for tree in self.prediction_forest.values():
            new_active[tree] = self._update_sequences_for_tree(
                tree, obs, action
                )

        # update
        self.active_sequences = new_active
        self.prev_obs = obs

    def _update_sequences_for_tree(self, tree, obs, action):
        matching = tree.get_nodes_from_obs(obs)
        updated = set()

        for sequence in self.active_sequences.get(tree, set()):
            _, next_node, edge_action = next(
                iter(tree.out_edges(sequence.current_node, data="action"))
            )
            # deactivate if the action does not match
            if edge_action != action:
                continue

            # reached prediction node => evaluate
            if next_node == tree.pred_node:
                self._update_prediction(
                    tree,
                    sequence.entry_node,
                    sequence.context,
                    correct_pred=(obs == tree.pred_obs),
                )

            # ordinary transition
            elif next_node in matching:
                sequence.current_node = next_node
                updated.add(sequence)
                matching.remove(next_node)

        # spawn new contexts
        for node in matching:
            updated.add(ActiveSequence(node, node, self.current_context))
        
        return updated
    
    def _update_prediction(self, tree, entry_node, context, correct_pred):
        entry_node = tree.nodes[entry_node]
        if not correct_pred:
            entry_node["confident"] = False
        elif not entry_node["confident"]:
            tree.reinforce_correct_prediction(entry_node, context)
            entry_node["confident"] = True